<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="http://groove-zhang.cn/oss/favicon.ico">
    <title> react 事件系统 </title>
</head>

<body>
    <div class="page">
        <div class="sider"> <div class='level-1'><a href="http://groove-zhang.cn/html/about.html">关于我</a></div><div class='level-1 folder'>web</div><div class='level-2 folder'>brower</div><div class='level-3'><a href="http://groove-zhang.cn/html/web/brower/brower.html">浏览器</a></div><div class='level-3'><a href="http://groove-zhang.cn/html/web/brower/cache.html">缓存相关</a></div><div class='level-3'><a href="http://groove-zhang.cn/html/web/brower/cors.html">跨域相关</a></div><div class='level-2 folder'>css</div><div class='level-2 folder'>engineered</div><div class='level-2 folder'>ideological</div><div class='level-3'><a href="http://groove-zhang.cn/html/web/ideological/js-design-patterns.html">设计模式-创建型</a></div><div class='level-2 folder'>interview</div><div class='level-2 folder'>jsCode</div><div class='level-3'><a href="http://groove-zhang.cn/html/web/jsCode/extend.html">js手写系列 - 对象继承</a></div><div class='level-3'><a href="http://groove-zhang.cn/html/web/jsCode/jsTools.html">js手写系列 - 工具方法</a></div><div class='level-3'><a href="http://groove-zhang.cn/html/web/jsCode/number-error.html">0.1 + 0.2 != 0.3</a></div><div class='level-3'><a href="http://groove-zhang.cn/html/web/jsCode/promise.html">js手写系列 - Promise</a></div><div class='level-2 folder'>network</div><div class='level-3'><a href="http://groove-zhang.cn/html/web/network/dns.html">网络协议 - DNS</a></div><div class='level-3'><a href="http://groove-zhang.cn/html/web/network/http.html">网络协议 - HTTP</a></div><div class='level-2 folder'>packages</div><div class='level-3'><a href="http://groove-zhang.cn/html/web/packages/check-dom.html">检查元素是否在页面上</a></div><div class='level-3'><a href="http://groove-zhang.cn/html/web/packages/cli.html">原来写一个脚手架如此容易</a></div><div class='level-3'><a href="http://groove-zhang.cn/html/web/packages/groove-cli.html">groove-cli中文文档</a></div><div class='level-2 folder'>react</div><div class='level-3'><a href="http://groove-zhang.cn/html/web/react/event.html">react 事件系统</a></div><div class='level-2 folder'>vue</div><div class='level-3'><a href="http://groove-zhang.cn/html/web/vue/vue-diff.html">vue diff算法解析</a></div> </div>
        <div class="content">
            <section>
                <h1>react 事件</h1>
<h2>概述</h2>
<ol>
<li>react 的事件绑定在document上统一管理，而不是真实的dom上。</li>
<li>dom上事件被单独处理，被react底层替换成空函数。</li>
<li>react绑定的事件，比如 onChange，document上可能有多个事件与之对应。</li>
<li>react 并不是一开始把所有事件都绑定在document上，而是采用一种按需绑定。</li>
</ol>
<p>在react中，我们绑定的onClick并不是原生事件，而是原生事件合成的react事件，比如click事件合成为onClick事件，比如blur，change，input，keydown等事件，合成为onchange。</p>
<p>那么为什么react要采用这样的模式？</p>
<p>第一、将所有事件绑定在document上统一管理，防止很多事件直接绑定在原生dom上，造成不可控的情况。
另一方面，react 想要实现一个全浏览器的框架，为了实现这种目标就需要提供给全浏览器一致性的事件系统，以此磨平不同浏览器的差异。</p>
<h2>事件初始化 - 事件合成 插件机制</h2>
<p>react并不是一次性将所有的事件都绑定进去，而是如果发现项目中有onClick事件，才绑定click事件，发现有onChange事件，才绑定blur，change等事件。</p>
<h3>事件合成 事件插件</h3>
<p>基础概念</p>
<ul>
<li>
<p>namesToPlugins</p>
<p>namesToPlugins装事件名 -&gt; 事件模块插件的映射。namesToPlugins最终的样子如：</p>
</li>
</ul>
<pre><code class="language-javascript">  const namesToPlugins = {
    SimpleEventPlugin,
    EnterLeaveEventPlugin,
    ChangeEventPlugin,
    SelectEventPlugin,
    BeforeInputEventPlugin,
}
</code></pre>
<p>simpleEventPlugin 等是处理各个事件函数的插件，比如以此点击事件，就会找到SimpleEventPlugin对应的处理函数。</p>
<ul>
<li>plugins</li>
</ul>
<p>这个对象就是上面注册的所有插件列表，初始化为空</p>
<ul>
<li>registrationNameModules</li>
</ul>
<p>registrationNameModules 记录了react合成的事件 - 对应的事件插件的关系，在react中处理props中事件的时候，会根据不同的事件名，找到对应的事件插件，然后统一绑定在document上，对于没有出现过的事件，就不会绑定。</p>
<pre><code class="language-javascript">{
    onBlur: SimpleEventPlugin,
    onClick: SimpleEventPlugin,
    onClickCapture: SimpleEventPlugin,
    onChange: ChangeEventPlugin,
    onChangeCapture: ChangeEventPlugin,
    onMouseEnter: EnterLeaveEventPlugin,
    onMouseLeave: EnterLeaveEventPlugin,
    ...
}
</code></pre>
<ul>
<li>事件插件</li>
</ul>
<pre><code class="language-javascript">const SimpleEventPlugin = {
    eventTypes:{ 
        'click':{ /* 处理点击事件  */
            phasedRegistrationNames:{
                bubbled: 'onClick',       // 对应的事件冒泡 - onClick 
                captured:'onClickCapture' //对应事件捕获阶段 - onClickCapture
            },
            dependencies: ['click'], //事件依赖
            ...
        },
        'blur':{ /* 处理失去焦点事件 */ },
        ...
    }
    extractEvents:function(topLevelType,targetInst,){ /* eventTypes 里面的事件对应的统一事件处理函数，接下来会重点讲到 */ }
}
</code></pre>
<p>事件插件是一个对象，有两个属性，第一个extractEvents作为事件统一处理函数，第二个eventTypes是一个对象，对象保存了原生事件名和对应的配置项dispatchConfig的映射关系，由于react的事件统一绑定在document上，react用独特的事件名称比如onClick和onClickCapture，来说明我们给绑定的函数到底是在冒泡截断还是捕获事件阶段执行。</p>
<ul>
<li>registrationNameDependencies</li>
</ul>
<p>registrationNameDependencies 用来记录，合成事件比如onClick和原生事件click对应关系。</p>
<pre><code class="language-javascript">{
    onBlur: ['blur'],
    onClick: ['click'],
    onClickCapture: ['click'],
    onChange: ['blur', 'change', 'click', 'focus', 'input', 'keydown', 'keyup', 'selectionchange'],
    onMouseEnter: ['mouseout', 'mouseover'],
    onMouseLeave: ['mouseout', 'mouseover'],
    ...
}
</code></pre>
<h3>事件初始化</h3>
<p>采用初始化注册方式</p>
<pre><code class="language-javascript">/* 第一步：注册事件：  */
injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin,
});
</code></pre>
<p>injectEventPluginsByName 做的事情很简单，形成了namesToPlugins，然后执行recomputePluginOrdering，那么recomeputePluginOrdering做了什么？</p>
<pre><code class="language-javascript">const eventPluginOrder = [ 'SimpleEventPlugin' , 'EnterLeaveEventPlugin','ChangeEventPlugin','SelectEventPlugin' , 'BeforeInputEventPlugin' ]

function recomputePluginOrdering(){
    for (const pluginName in namesToPlugins) {
        /* 找到对应的事件处理插件，比如 SimpleEventPlugin  */
        const pluginModule = namesToPlugins[pluginName];
        const pluginIndex = eventPluginOrder.indexOf(pluginName);
        /* 填充 plugins 数组  */
        plugins[pluginIndex] = pluginModule;
        const publishedEvents = pluginModule.eventTypes;
        for (const eventName in publishedEvents) {
        // publishedEvents[eventName] -&gt; eventConfig , pluginModule -&gt; 事件插件 ， eventName -&gt; 事件名称
            publishEventForPlugin(publishedEvents[eventName],pluginModule,eventName,)
        } 
    }
}
</code></pre>
<p>recomputePluginOrdering 的作用是形成plugins，然后执行publishEventForPlugin</p>
<pre><code class="language-javascript">/*
  dispatchConfig -&gt; 原生事件对应配置项 { phasedRegistrationNames :{  冒泡 捕获  } ，   }
  pluginModule -&gt; 事件插件 比如SimpleEventPlugin  
  eventName -&gt; 原生事件名称。
*/
function publishEventForPlugin (dispatchConfig,pluginModule,eventName){
    eventNameDispatchConfigs[eventName] = dispatchConfig;
    /* 事件 */
    const phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
    if (phasedRegistrationNames) {
    for (const phaseName in phasedRegistrationNames) {
        if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
            // phasedRegistrationName React事件名 比如 onClick / onClickCapture
            const phasedRegistrationName = phasedRegistrationNames[phaseName];
            // 填充形成 registrationNameModules React 合成事件 -&gt; React 处理事件插件映射关系
            registrationNameModules[phasedRegistrationName] = pluginModule;
            // 填充形成 registrationNameDependencies React 合成事件 -&gt; 原生事件 映射关系
            registrationNameDependencies[phasedRegistrationName] = pluginModule.eventTypes[eventName].dependencies;
        }
    }
    return true;
    }
}

</code></pre>
<p>publishEventForPlugin 形成了registrationNameModules和registrationNameDependencies对象中的映射关系。</p>
<h3>事件合成总结</h3>
<p>初始化阶段主要是形成了上述的几个重要对象，构建初始化React合成事件和原生事件的对应关系，合成事件和对应的事件处理插件关系。</p>
<h2>事件绑定 - 从一次点击事件开始</h2>
<h3>事件绑定流程</h3>
<ol>
<li>diffProperties处理React合成事件</li>
</ol>
<pre><code class="language-javascript">&lt;div&gt;
  &lt;button onClick={ this.handerClick }  className=&quot;button&quot; &gt;点击&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<p>我们绑定给hostComponent种类的fiber，button对应的fiber上，以memoizedProps和pendingProps形式保存；</p>
<pre><code class="language-javascript">// button 对应 fiber
memoizedProps = {
   onClick:function handerClick(){},
   className:'button'
}
</code></pre>
<p>第二步 react在调和子节点后，进入diff阶段，判断hostComponent类型的fiber，会用diff props函数diffProperties单独处理。</p>
<pre><code class="language-javascript">function diffProperties(){
    /* 判断当前的 propKey 是不是 React合成事件 */
    if(registrationNameModules.hasOwnProperty(propKey)){
         /* 这里多个函数简化了，如果是合成事件， 传入成事件名称 onClick ，向document注册事件  */
         legacyListenToEvent(registrationName, document）;
    }
}
</code></pre>
<p>diffProperties函数在diff props 如果发现时合成事件就会调用legacyListenToEvent函数，注册事件监听器。</p>
<ol start="2">
<li>legacyListenToEvent 注册事件监听器</li>
</ol>
<pre><code class="language-javascript">//  registrationName -&gt; onClick 事件
//  mountAt -&gt; document or container
function legacyListenToEvent(registrationName，mountAt){
   const dependencies = registrationNameDependencies[registrationName]; // 根据 onClick 获取  onClick 依赖的事件数组 [ 'click' ]。
    for (let i = 0; i &lt; dependencies.length; i++) {
        const dependency = dependencies[i];
        //这个经过多个函数简化，如果是 click 基础事件，会走 legacyTrapBubbledEvent ,而且都是按照冒泡处理
        legacyTrapBubbledEvent(dependency, mountAt);
  }
}
</code></pre>
<p>legacyTrapBubbledEvent 就是执行将绑定真正的dom事件的函数（冒泡处理）</p>
<pre><code class="language-javascript">function legacyTrapBubbledEvent(topLevelType,element){
   addTrappedEventListener(element,topLevelType,PLUGIN_EVENT_SYSTEM,false)
}
</code></pre>
<p>第三步在legacyListenToEvent函数中，先找到react合成事件对应的原生事件集合，比如 onClick -&gt; ['click'] , onChange -&gt; [blur , change , input , keydown , keyup]，然后遍历依赖项的数组，绑定事件。</p>
<p>react 对于click等基础事件，会默认按事件冒泡阶段的事件处理。</p>
<ol start="3">
<li>绑定dispatchEvent进行事件监听。</li>
</ol>
<p>react是如何绑定事件到document。</p>
<pre><code class="language-javascript">/*
  targetContainer -&gt; document
  topLevelType -&gt;  click
  capture = false
*/
function addTrappedEventListener(targetContainer,topLevelType,eventSystemFlags,capture){
   const listener = dispatchEvent.bind(null,topLevelType,eventSystemFlags,targetContainer) 
   if(capture){
       // 事件捕获阶段处理函数。
   }else{
       /* TODO: 重要, 这里进行真正的事件绑定。*/
      targetContainer.addEventListener(topLevelType,listener,false) // document.addEventListener('click',listener,false)
   }
}

</code></pre>
<p>第四步，绑定事件统一处理函数 dispatchEvent ，绑定几个默认参数，事件类型topLevelType 还有绑定容器 document，然后真正的事件绑定，添加事件监听器addEventListener。</p>
<h3>事件绑定过程总结</h3>
<ul>
<li>在react diff dom元素类型的fiber的props的时候，发现是react合成事件，就会按事件系统逻辑单独处理。</li>
<li>根据react 合成事件类型，找到对应的原生事件类型，然后调用判断原生事件类型，大部分事件都按照冒泡逻辑处理，少数事件会按照捕获逻辑处理。</li>
<li>调用addTrappedEventListener 进行真正的事件绑定，绑定document上，dispatchEvent为统一的事件处理函数。</li>
</ul>
<h2>事件触发</h2>
<h3>事件触发处理函数 dispatchEvent</h3>
<p>react事件注册时候，统一的监听器dispathchEvent，也就是当按钮被点击之后，首先执行的是dispatchEvent函数，dispatchEvent前三个参数已经被bind了，所以真正的事件源对象event，被默认绑定成第四个参数。</p>
<pre><code class="language-javascript">function dispatchEvent(topLevelType,eventSystemFlags,targetContainer,nativeEvent){
    /* 尝试调度事件 */
    const blockedOn = attemptToDispatchEvent( topLevelType,eventSystemFlags, targetContainer, nativeEvent);
}
</code></pre>
<pre><code class="language-javascript">/*
topLevelType -&gt; click
eventSystemFlags -&gt; 1
targetContainer -&gt; document
nativeEvent -&gt; 原生事件的 event 对象
*/
function attemptToDispatchEvent(topLevelType,eventSystemFlags,targetContainer,nativeEvent){
    /* 获取原生事件 e.target */
    const nativeEventTarget = getEventTarget(nativeEvent)
    /* 获取当前事件，最近的dom类型fiber ，我们 demo中 button 按钮对应的 fiber */
    let targetInst = getClosestInstanceFromNode(nativeEventTarget); 
    /* 重要：进入legacy模式的事件处理系统 */
    dispatchEventForLegacyPluginEventSystem(topLevelType,eventSystemFlags,nativeEvent,targetInst,);
    return null;
}
</code></pre>
<ul>
<li>首先根据真实的事件源对象,找到e.target 真实的dom元素</li>
<li>根据dom元素，找到它对应的fiber对象targetInst.</li>
<li>然后正式进去legacy模式的事件处理系统。</li>
</ul>
<p>react怎么通过原生dom元素，找到对应的fiber的呢？
getClosestInstanceFromNode 可以找到当前传入的dom对应的最近的元素类型的fiber对象。react在初始化真实的dom的时候，用一个随记的key 。
internalInstanceKey指针纸箱了当前dom对应的fiber对象，fiber对象用stateNode指向了当前的dom元素。</p>
<pre><code>// 声明随机key
var internalInstanceKey = '__reactInternalInstance
            </section>
        </div>
    </div>
</body>
<style>
    body,
    div,
    dl,
    dt,
    dd,
    ul,
    ol,
    li,
    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    pre,
    code,
    legend,
    button form,
    fieldset,
    input,
    textarea,
    p,
    blockquote,
    th,
    td {
        padding: 0;
        margin: 0;
    }

    body {
        color: #34495e;
    }

    a {
        text-decoration: none;
        color: #505d6b;

    }

    a:hover {
        text-decoration: underline;
    }

    .page {
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        display: flex;
        align-items: flex-start;
        justify-content: flex-start;
    }

    .sider {
        flex-shrink: 0;
        box-sizing: border-box;
        padding: 10px;
        height: 100%;
        min-width: 200px;
        width: 300px;
        background-color: white;
        overflow: hidden;
        overflow-y: auto;
        border: 1px solid rgba(0, 0, 0, 0.07);
    }

    .content {
        height: 100%;
        flex-grow: 1;
        padding: 0 30px;
        background-color: white;
        overflow: hidden;
        overflow-y: auto;
    }

    .level-1,
    .level-2,
    .level-3 {
        color: #505d6b;
        font-size: 14px;
        font-weight: 400;
        overflow: hidden;
        text-decoration: none;
        text-overflow: ellipsis;
        white-space: nowrap;
        margin-top: 6px;
        line-height: 30px;
    }

    .level-1 {
        text-indent: 10px;
    }

    .level-2 {
        text-indent: 20px;
    }

    .level-3 {
        text-indent: 30px;
    }

    .folder {
        font-weight: 600;
        margin-top: 6px;
    }

    section {
        min-width: 880px;
        max-width: 1200px;
        margin: 0 auto;
        padding: 30px 0;
    }

    img {
        max-width: 100%;
    }

    section p {
        margin: 1.2em 0;
        line-height: 25px;
    }

    section h1,
    section h2,
    section h3,
    section h4,
    section h5 {
        color: #2c3e50;
        font-weight: 600;
    }

    hr {
        border: none;
        border-bottom: 1px solid #eee;
        margin: 2em 0;
    }

    h1 {
        margin-top: 40px;
    }

    h2 {
        margin-top: 32px;
    }

    h3 {
        margin-top: 24px;
    }

    h4 {
        margin-top: 16px;
    }

    h5 {
        margin-top: 8px;
    }

    section ul,
    section ol {
        padding-left: 24px;
    }

    section pre {
        padding: 20px 44px;
        line-height: 24px;
        overflow: auto;
        word-wrap: normal;
        background-color: #f8f8f8;
        border-radius: 5px;
        margin: 30px 0;
    }

    section table {
        border-collapse: collapse;
        border-spacing: 0;
        display: block;
        margin-bottom: 1rem;
        overflow: auto;
        width: 100%;
    }

    section tr {
        border-top: 1px solid #ccc;
    }

    section td {
        border: 1px solid #ddd;
        padding: 6px 13px;
    }

    section th {
        border: 1px solid #ddd;
        padding: 6px 13px;
    }

    thead {
        display: table-header-group;
        vertical-align: middle;
        border-color: inherit;
    }

    code {
        margin: 30px 2px;
    }
</style>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        let url = location.href;
        let aEl = document.getElementsByTagName('a');
        for (let el of aEl) {
            if (el.href === url) {
                el.style.color = 'rgb(66, 185, 131)'
            }
        }
    })
</script>

</html> + randomKey;

// 使用随机key 
function getClosestInstanceFromNode(targetNode){
  // targetNode -dom  targetInst -&gt; 与之对应的fiber对象
  var targetInst = targetNode[internalInstanceKey];
}
</code></pre>
<h3>legacy 事件处理系统与批量更新</h3>
<pre><code class="language-javascript">/* topLevelType - click事件 ｜ eventSystemFlags = 1 ｜ nativeEvent = 事件源对象  ｜ targetInst = 元素对应的fiber对象  */
function dispatchEventForLegacyPluginEventSystem(topLevelType,eventSystemFlags,nativeEvent,targetInst){
    /* 从React 事件池中取出一个，将 topLevelType ，targetInst 等属性赋予给事件  */
    const bookKeeping = getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst,eventSystemFlags);
    try { /* 执行批量更新 handleTopLevel 为事件处理的主要函数 */
    batchedEventUpdates(handleTopLevel, bookKeeping);
  } finally {
    /* 释放事件池 */  
    releaseTopLevelCallbackBookKeeping(bookKeeping);
  }
}
</code></pre>
<p>batchedEventUpdates 是批量更新的主要函数。</p>
<pre><code class="language-javascript">export function batchedEventUpdates(fn,a){
    isBatchingEventUpdates = true;
    try{
       fn(a) // handleTopLevel(bookKeeping)
    }finally{
        isBatchingEventUpdates = false
    }
}
</code></pre>
<p>react 通过isBatchingEventUpdates来控制是否启动批量更新。fn(a)时间上调用的是handleTopLevel(bookKeeping)，js是单线程，因为js是单线程的，所以在组件中写的事件处理函数时机是在handleTopLevel(bookKeeping)中执行的。如果在用户事件处理函数中触发了setState，那么就能读取到 isBatchingEventUpdates = true 。</p>
<pre><code>state={number:0}
handerClick = () =&gt;{
    this.setState({number: this.state.number + 1   })
    console.log(this.state.number) //0
    this.setState({number: this.state.number + 1   })
    console.log(this.state.number) //0
    setTimeout(()=&gt;{
        this.setState({number: this.state.number + 1   })
        console.log(this.state.number) //2
        this.setState({number: this.state.number + 1   })
        console.log(this.state.number)// 3
    })
}
</code></pre>
<p>第一二个setState在批量更新条件之内执行，所以不会打印最新的值。
如果发生在setTimeout中，eventloop放在下一次事件循环中执行，此刻batchedEventUpdates 中已经执行完了isBatchingEventUpdates = false , 批量更新被打破，就可以访问到最新的变化的值。</p>
<h3>执行事件插件函数</h3>
<pre><code>// 流程简化后
// topLevelType - click  
// targetInst - button Fiber
// nativeEvent
function handleTopLevel(bookKeeping){
    const { topLevelType,targetInst,nativeEvent,eventTarget, eventSystemFlags} = bookKeeping
    for(let i=0; i &lt; plugins.length;i++ ){
        const possiblePlugin = plugins[i];
        /* 找到对应的事件插件，形成对应的合成event，形成事件执行队列  */
        const  extractedEvents = possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,eventTarget,eventSystemFlags)  
    }
    if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
    }
    /* 执行事件处理函数 */
    runEventsInBatch(events);
}
</code></pre>
<p>handleTopLevel最后的处理逻辑是执行事件处理插件中的处理函数 extractEvents, react是采用事件合成，事件统一绑定，并且在组件中的时间处理函数，也不是真正的执行函数dispatchAction,那么我们在点击事件对象event，也是react单独合成处理的，里面封装了stopPropagetion和preventDefault。这样的好处是不需要跨浏览器处理兼容问题，统一交给react底层处理。</p>
<h3>extractEvents 形成事件对象和是按处理函数队列</h3>
<p>extraEvent 是整个事件系统核心代码。</p>
<pre><code class="language-javascript">const  SimpleEventPlugin = {
    extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget){
        const dispatchConfig = topLevelEventsToDispatchConfig.get(topLevelType);
        if (!dispatchConfig) {
            return null;
        }
        switch(topLevelType){
            default:
            EventConstructor = SyntheticEvent;
            break;
        }
        /* 产生事件源对象 */
        const event = EventConstructor.getPooled(dispatchConfig,targetInst,nativeEvent,nativeEventTarget)
        const phasedRegistrationNames = event.dispatchConfig.phasedRegistrationNames;
        const dispatchListeners = [];
        const {bubbled, captured} = phasedRegistrationNames; /* onClick / onClickCapture */
        const dispatchInstances = [];
        /* 从事件源开始逐渐向上，查找dom元素类型HostComponent对应的fiber ，收集上面的React合成事件，onClick / onClickCapture  */
         while (instance !== null) {
              const {stateNode, tag} = instance;
              if (tag === HostComponent &amp;&amp; stateNode !== null) { /* DOM 元素 */
                   const currentTarget = stateNode;
                   if (captured !== null) { /* 事件捕获 */
                        /* 在事件捕获阶段,真正的事件处理函数 */
                        const captureListener = getListener(instance, captured);
                        if (captureListener != null) {
                        /* 对应发生在事件捕获阶段的处理函数，逻辑是将执行函数unshift添加到队列的最前面 */
                            dispatchListeners.unshift(captureListener);
                            dispatchInstances.unshift(instance);
                            dispatchCurrentTargets.unshift(currentTarget);
                        }
                    }
                    if (bubbled !== null) { /* 事件冒泡 */
                        /* 事件冒泡阶段，真正的事件处理函数，逻辑是将执行函数push到执行队列的最后面 */
                        const bubbleListener = getListener(instance, bubbled);
                        if (bubbleListener != null) {
                            dispatchListeners.push(bubbleListener);
                            dispatchInstances.push(instance);
                            dispatchCurrentTargets.push(currentTarget);
                        }
                    }
              }
              instance = instance.return;
         }
          if (dispatchListeners.length &gt; 0) {
              /* 将函数执行队列，挂到事件对象event上 */
            event._dispatchListeners = dispatchListeners;
            event._dispatchInstances = dispatchInstances;
            event._dispatchCurrentTargets = dispatchCurrentTargets;
         }
        return event
    }
}

</code></pre>
<ul>
<li>首先形成react事件独有的合成事件源对象，这个对象保存整个事件的信息，将作为参数传递给真正的事件处理函数 。</li>
<li>然后去声明事件执行队列，按照冒泡 和 捕获 逻辑。从事件源开始逐渐向上，查找dom元素类型HostComponent对应的fiber，收集上面的react合成事件。</li>
<li>最后将事件执行队列，保存到react事件源对象上，等待执行。</li>
</ul>
<h3>事件触发总结</h3>
<ul>
<li>通过统一的事件处理函数 dispatchEvent 进行批量更新batchUpdate</li>
<li>然后执行事件对应的处理插件中的extractEvents，合成事件源对象，每次react会从事件源开始，从上遍历类型为hostComponent【dom类型的fiber对象】，判断props中是否有当前响应的事件，最后形成一个事件执行队列。</li>
<li>最后通过runEventsInBatch执行队列，如果发现阻止冒泡，就会跳出循环，最后重置事件源，完成流程。</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68a8f1b7f35c4ecbb58cf9d676cd29ad~tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<h3>react 17 改版</h3>
<p>事件统一绑定到了挂载的根节点上，目标是为了适应微前端框架。</p>
<h2>总结</h2>
<p>本文从事件合成，事件绑定，事件触发三个方面详细介绍了React事件系统原理。
贴一下原文地址</p>
<blockquote>
<p>https://juejin.cn/post/6955636911214067720#heading-23</p>
</blockquote>

            </section>
        </div>
    </div>
</body>
<style>
    body,
    div,
    dl,
    dt,
    dd,
    ul,
    ol,
    li,
    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    pre,
    code,
    legend,
    button form,
    fieldset,
    input,
    textarea,
    p,
    blockquote,
    th,
    td {
        padding: 0;
        margin: 0;
    }

    body {
        color: #34495e;
    }

    a {
        text-decoration: none;
        color: #505d6b;

    }

    a:hover {
        text-decoration: underline;
    }

    .page {
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        display: flex;
        align-items: flex-start;
        justify-content: flex-start;
    }

    .sider {
        flex-shrink: 0;
        box-sizing: border-box;
        padding: 10px;
        height: 100%;
        min-width: 200px;
        width: 300px;
        background-color: white;
        overflow: hidden;
        overflow-y: auto;
        border: 1px solid rgba(0, 0, 0, 0.07);
    }

    .content {
        height: 100%;
        flex-grow: 1;
        padding: 0 30px;
        background-color: white;
        overflow: hidden;
        overflow-y: auto;
    }

    .level-1,
    .level-2,
    .level-3 {
        color: #505d6b;
        font-size: 14px;
        font-weight: 400;
        overflow: hidden;
        text-decoration: none;
        text-overflow: ellipsis;
        white-space: nowrap;
        margin-top: 6px;
        line-height: 30px;
    }

    .level-1 {
        text-indent: 10px;
    }

    .level-2 {
        text-indent: 20px;
    }

    .level-3 {
        text-indent: 30px;
    }

    .folder {
        font-weight: 600;
        margin-top: 6px;
    }

    section {
        min-width: 880px;
        max-width: 1200px;
        margin: 0 auto;
        padding: 30px 0;
    }

    img {
        max-width: 100%;
    }

    section p {
        margin: 1.2em 0;
        line-height: 25px;
    }

    section h1,
    section h2,
    section h3,
    section h4,
    section h5 {
        color: #2c3e50;
        font-weight: 600;
    }

    hr {
        border: none;
        border-bottom: 1px solid #eee;
        margin: 2em 0;
    }

    h1 {
        margin-top: 40px;
    }

    h2 {
        margin-top: 32px;
    }

    h3 {
        margin-top: 24px;
    }

    h4 {
        margin-top: 16px;
    }

    h5 {
        margin-top: 8px;
    }

    section ul,
    section ol {
        padding-left: 24px;
    }

    section pre {
        padding: 20px 44px;
        line-height: 24px;
        overflow: auto;
        word-wrap: normal;
        background-color: #f8f8f8;
        border-radius: 5px;
        margin: 30px 0;
    }

    section table {
        border-collapse: collapse;
        border-spacing: 0;
        display: block;
        margin-bottom: 1rem;
        overflow: auto;
        width: 100%;
    }

    section tr {
        border-top: 1px solid #ccc;
    }

    section td {
        border: 1px solid #ddd;
        padding: 6px 13px;
    }

    section th {
        border: 1px solid #ddd;
        padding: 6px 13px;
    }

    thead {
        display: table-header-group;
        vertical-align: middle;
        border-color: inherit;
    }

    code {
        margin: 30px 2px;
    }
</style>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        let url = location.href;
        let aEl = document.getElementsByTagName('a');
        for (let el of aEl) {
            if (el.href === url) {
                el.style.color = 'rgb(66, 185, 131)'
            }
        }
    })
</script>

</html>