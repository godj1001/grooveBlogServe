<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="http://groove-zhang.cn/oss/favicon.ico">
    <title> react 事件系统 </title>
</head>

<body>
    <div class="page">
        <div class="sider"> <div class='level-1'><a href="http://localhost:3000/html/about.html">关于我</a></div><div class='level-1 folder'>web</div><div class='level-2 folder'>brower</div><div class='level-3'><a href="http://localhost:3000/html/web/brower/brower.html">浏览器</a></div><div class='level-3'><a href="http://localhost:3000/html/web/brower/cache.html">缓存相关</a></div><div class='level-3'><a href="http://localhost:3000/html/web/brower/cors.html">跨域相关</a></div><div class='level-2 folder'>css</div><div class='level-2 folder'>engineered</div><div class='level-2 folder'>ideological</div><div class='level-3'><a href="http://localhost:3000/html/web/ideological/js-design-patterns.html">设计模式-创建型</a></div><div class='level-2 folder'>interview</div><div class='level-2 folder'>jsCode</div><div class='level-3'><a href="http://localhost:3000/html/web/jsCode/extend.html">js手写系列 - 对象继承</a></div><div class='level-3'><a href="http://localhost:3000/html/web/jsCode/jsTools.html">js手写系列 - 工具方法</a></div><div class='level-3'><a href="http://localhost:3000/html/web/jsCode/number-error.html">0.1 + 0.2 != 0.3</a></div><div class='level-3'><a href="http://localhost:3000/html/web/jsCode/promise.html">js手写系列 - Promise</a></div><div class='level-2 folder'>network</div><div class='level-3'><a href="http://localhost:3000/html/web/network/dns.html">网络协议 - DNS</a></div><div class='level-3'><a href="http://localhost:3000/html/web/network/http.html">网络协议 - HTTP</a></div><div class='level-2 folder'>packages</div><div class='level-3'><a href="http://localhost:3000/html/web/packages/blog.html">构建一个博客服务器</a></div><div class='level-3'><a href="http://localhost:3000/html/web/packages/check-dom.html">检查元素是否在页面上</a></div><div class='level-3'><a href="http://localhost:3000/html/web/packages/cli.html">原来写一个脚手架如此容易</a></div><div class='level-3'><a href="http://localhost:3000/html/web/packages/groove-cli.html">groove-cli中文文档</a></div><div class='level-2 folder'>react</div><div class='level-3'><a href="http://localhost:3000/html/web/react/event.html">react 事件系统</a></div><div class='level-2 folder'>vue</div><div class='level-3'><a href="http://localhost:3000/html/web/vue/vue-diff.html">vue diff算法解析</a></div> </div>
        <div class="content">
            <section>
                <h1>react 事件</h1>
<h2>概述</h2>
<ol>
<li>react 的事件绑定在document上统一管理，而不是真实的dom上。</li>
<li>dom上事件被单独处理，被react底层替换成空函数。</li>
<li>react绑定的事件，比如 onChange，document上可能有多个事件与之对应。</li>
<li>react 并不是一开始把所有事件都绑定在document上，而是采用一种按需绑定。</li>
</ol>
<p>在react中，我们绑定的onClick并不是原生事件，而是原生事件合成的react事件，比如click事件合成为onClick事件，比如blur，change，input，keydown等事件，合成为onchange。</p>
<p>那么为什么react要采用这样的模式？</p>
<p>第一、将所有事件绑定在document上统一管理，防止很多事件直接绑定在原生dom上，造成不可控的情况。
另一方面，react 想要实现一个全浏览器的框架，为了实现这种目标就需要提供给全浏览器一致性的事件系统，以此磨平不同浏览器的差异。</p>
<h2>事件初始化 - 事件合成 插件机制</h2>
<p>react并不是一次性将所有的事件都绑定进去，而是如果发现项目中有onClick事件，才绑定click事件，发现有onChange事件，才绑定blur，change等事件。</p>
<h3>事件合成 事件插件</h3>
<p>基础概念</p>
<ul>
<li>
<p>namesToPlugins</p>
<p>namesToPlugins装事件名 -&gt; 事件模块插件的映射。namesToPlugins最终的样子如：</p>
</li>
</ul>
<pre><code class="language-javascript">  <span class="hljs-keyword">const</span> namesToPlugins = {
    <span class="hljs-title class_">SimpleEventPlugin</span>,
    <span class="hljs-title class_">EnterLeaveEventPlugin</span>,
    <span class="hljs-title class_">ChangeEventPlugin</span>,
    <span class="hljs-title class_">SelectEventPlugin</span>,
    <span class="hljs-title class_">BeforeInputEventPlugin</span>,
}
</code></pre>
<p>simpleEventPlugin 等是处理各个事件函数的插件，比如以此点击事件，就会找到SimpleEventPlugin对应的处理函数。</p>
<ul>
<li>plugins</li>
</ul>
<p>这个对象就是上面注册的所有插件列表，初始化为空</p>
<ul>
<li>registrationNameModules</li>
</ul>
<p>registrationNameModules 记录了react合成的事件 - 对应的事件插件的关系，在react中处理props中事件的时候，会根据不同的事件名，找到对应的事件插件，然后统一绑定在document上，对于没有出现过的事件，就不会绑定。</p>
<pre><code class="language-javascript">{
    <span class="hljs-attr">onBlur</span>: <span class="hljs-title class_">SimpleEventPlugin</span>,
    <span class="hljs-attr">onClick</span>: <span class="hljs-title class_">SimpleEventPlugin</span>,
    <span class="hljs-attr">onClickCapture</span>: <span class="hljs-title class_">SimpleEventPlugin</span>,
    <span class="hljs-attr">onChange</span>: <span class="hljs-title class_">ChangeEventPlugin</span>,
    <span class="hljs-attr">onChangeCapture</span>: <span class="hljs-title class_">ChangeEventPlugin</span>,
    <span class="hljs-attr">onMouseEnter</span>: <span class="hljs-title class_">EnterLeaveEventPlugin</span>,
    <span class="hljs-attr">onMouseLeave</span>: <span class="hljs-title class_">EnterLeaveEventPlugin</span>,
    ...
}
</code></pre>
<ul>
<li>事件插件</li>
</ul>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">SimpleEventPlugin</span> = {
    <span class="hljs-attr">eventTypes</span>:{ 
        <span class="hljs-string">&#x27;click&#x27;</span>:{ <span class="hljs-comment">/* 处理点击事件  */</span>
            <span class="hljs-attr">phasedRegistrationNames</span>:{
                <span class="hljs-attr">bubbled</span>: <span class="hljs-string">&#x27;onClick&#x27;</span>,       <span class="hljs-comment">// 对应的事件冒泡 - onClick </span>
                <span class="hljs-attr">captured</span>:<span class="hljs-string">&#x27;onClickCapture&#x27;</span> <span class="hljs-comment">//对应事件捕获阶段 - onClickCapture</span>
            },
            <span class="hljs-attr">dependencies</span>: [<span class="hljs-string">&#x27;click&#x27;</span>], <span class="hljs-comment">//事件依赖</span>
            ...
        },
        <span class="hljs-string">&#x27;blur&#x27;</span>:{ <span class="hljs-comment">/* 处理失去焦点事件 */</span> },
        ...
    }
    <span class="hljs-attr">extractEvents</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">topLevelType,targetInst,</span>){ <span class="hljs-comment">/* eventTypes 里面的事件对应的统一事件处理函数，接下来会重点讲到 */</span> }
}
</code></pre>
<p>事件插件是一个对象，有两个属性，第一个extractEvents作为事件统一处理函数，第二个eventTypes是一个对象，对象保存了原生事件名和对应的配置项dispatchConfig的映射关系，由于react的事件统一绑定在document上，react用独特的事件名称比如onClick和onClickCapture，来说明我们给绑定的函数到底是在冒泡截断还是捕获事件阶段执行。</p>
<ul>
<li>registrationNameDependencies</li>
</ul>
<p>registrationNameDependencies 用来记录，合成事件比如onClick和原生事件click对应关系。</p>
<pre><code class="language-javascript">{
    <span class="hljs-attr">onBlur</span>: [<span class="hljs-string">&#x27;blur&#x27;</span>],
    <span class="hljs-attr">onClick</span>: [<span class="hljs-string">&#x27;click&#x27;</span>],
    <span class="hljs-attr">onClickCapture</span>: [<span class="hljs-string">&#x27;click&#x27;</span>],
    <span class="hljs-attr">onChange</span>: [<span class="hljs-string">&#x27;blur&#x27;</span>, <span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-string">&#x27;focus&#x27;</span>, <span class="hljs-string">&#x27;input&#x27;</span>, <span class="hljs-string">&#x27;keydown&#x27;</span>, <span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-string">&#x27;selectionchange&#x27;</span>],
    <span class="hljs-attr">onMouseEnter</span>: [<span class="hljs-string">&#x27;mouseout&#x27;</span>, <span class="hljs-string">&#x27;mouseover&#x27;</span>],
    <span class="hljs-attr">onMouseLeave</span>: [<span class="hljs-string">&#x27;mouseout&#x27;</span>, <span class="hljs-string">&#x27;mouseover&#x27;</span>],
    ...
}
</code></pre>
<h3>事件初始化</h3>
<p>采用初始化注册方式</p>
<pre><code class="language-javascript"><span class="hljs-comment">/* 第一步：注册事件：  */</span>
<span class="hljs-title function_">injectEventPluginsByName</span>({
    <span class="hljs-title class_">SimpleEventPlugin</span>: <span class="hljs-title class_">SimpleEventPlugin</span>,
    <span class="hljs-title class_">EnterLeaveEventPlugin</span>: <span class="hljs-title class_">EnterLeaveEventPlugin</span>,
    <span class="hljs-title class_">ChangeEventPlugin</span>: <span class="hljs-title class_">ChangeEventPlugin</span>,
    <span class="hljs-title class_">SelectEventPlugin</span>: <span class="hljs-title class_">SelectEventPlugin</span>,
    <span class="hljs-title class_">BeforeInputEventPlugin</span>: <span class="hljs-title class_">BeforeInputEventPlugin</span>,
});
</code></pre>
<p>injectEventPluginsByName 做的事情很简单，形成了namesToPlugins，然后执行recomputePluginOrdering，那么recomeputePluginOrdering做了什么？</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span> eventPluginOrder = [ <span class="hljs-string">&#x27;SimpleEventPlugin&#x27;</span> , <span class="hljs-string">&#x27;EnterLeaveEventPlugin&#x27;</span>,<span class="hljs-string">&#x27;ChangeEventPlugin&#x27;</span>,<span class="hljs-string">&#x27;SelectEventPlugin&#x27;</span> , <span class="hljs-string">&#x27;BeforeInputEventPlugin&#x27;</span> ]

<span class="hljs-keyword">function</span> <span class="hljs-title function_">recomputePluginOrdering</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> pluginName <span class="hljs-keyword">in</span> namesToPlugins) {
        <span class="hljs-comment">/* 找到对应的事件处理插件，比如 SimpleEventPlugin  */</span>
        <span class="hljs-keyword">const</span> pluginModule = namesToPlugins[pluginName];
        <span class="hljs-keyword">const</span> pluginIndex = eventPluginOrder.<span class="hljs-title function_">indexOf</span>(pluginName);
        <span class="hljs-comment">/* 填充 plugins 数组  */</span>
        plugins[pluginIndex] = pluginModule;
        <span class="hljs-keyword">const</span> publishedEvents = pluginModule.<span class="hljs-property">eventTypes</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> eventName <span class="hljs-keyword">in</span> publishedEvents) {
        <span class="hljs-comment">// publishedEvents[eventName] -&gt; eventConfig , pluginModule -&gt; 事件插件 ， eventName -&gt; 事件名称</span>
            <span class="hljs-title function_">publishEventForPlugin</span>(publishedEvents[eventName],pluginModule,eventName,)
        } 
    }
}
</code></pre>
<p>recomputePluginOrdering 的作用是形成plugins，然后执行publishEventForPlugin</p>
<pre><code class="language-javascript"><span class="hljs-comment">/*
  dispatchConfig -&gt; 原生事件对应配置项 { phasedRegistrationNames :{  冒泡 捕获  } ，   }
  pluginModule -&gt; 事件插件 比如SimpleEventPlugin  
  eventName -&gt; 原生事件名称。
*/</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">publishEventForPlugin</span> (dispatchConfig,pluginModule,eventName){
    eventNameDispatchConfigs[eventName] = dispatchConfig;
    <span class="hljs-comment">/* 事件 */</span>
    <span class="hljs-keyword">const</span> phasedRegistrationNames = dispatchConfig.<span class="hljs-property">phasedRegistrationNames</span>;
    <span class="hljs-keyword">if</span> (phasedRegistrationNames) {
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> phaseName <span class="hljs-keyword">in</span> phasedRegistrationNames) {
        <span class="hljs-keyword">if</span> (phasedRegistrationNames.<span class="hljs-title function_">hasOwnProperty</span>(phaseName)) {
            <span class="hljs-comment">// phasedRegistrationName React事件名 比如 onClick / onClickCapture</span>
            <span class="hljs-keyword">const</span> phasedRegistrationName = phasedRegistrationNames[phaseName];
            <span class="hljs-comment">// 填充形成 registrationNameModules React 合成事件 -&gt; React 处理事件插件映射关系</span>
            registrationNameModules[phasedRegistrationName] = pluginModule;
            <span class="hljs-comment">// 填充形成 registrationNameDependencies React 合成事件 -&gt; 原生事件 映射关系</span>
            registrationNameDependencies[phasedRegistrationName] = pluginModule.<span class="hljs-property">eventTypes</span>[eventName].<span class="hljs-property">dependencies</span>;
        }
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
}

</code></pre>
<p>publishEventForPlugin 形成了registrationNameModules和registrationNameDependencies对象中的映射关系。</p>
<h3>事件合成总结</h3>
<p>初始化阶段主要是形成了上述的几个重要对象，构建初始化React合成事件和原生事件的对应关系，合成事件和对应的事件处理插件关系。</p>
<h2>事件绑定 - 从一次点击事件开始</h2>
<h3>事件绑定流程</h3>
<ol>
<li>diffProperties处理React合成事件</li>
</ol>
<pre><code class="language-javascript">&lt;div&gt;
  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{</span> <span class="hljs-attr">this.handerClick</span> }  <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;button&quot;</span> &gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
&lt;/div&gt;
</code></pre>
<p>我们绑定给hostComponent种类的fiber，button对应的fiber上，以memoizedProps和pendingProps形式保存；</p>
<pre><code class="language-javascript"><span class="hljs-comment">// button 对应 fiber</span>
memoizedProps = {
   <span class="hljs-attr">onClick</span>:<span class="hljs-keyword">function</span> <span class="hljs-title function_">handerClick</span>(<span class="hljs-params"></span>){},
   <span class="hljs-attr">className</span>:<span class="hljs-string">&#x27;button&#x27;</span>
}
</code></pre>
<p>第二步 react在调和子节点后，进入diff阶段，判断hostComponent类型的fiber，会用diff props函数diffProperties单独处理。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">diffProperties</span>(<span class="hljs-params"></span>){
    <span class="hljs-comment">/* 判断当前的 propKey 是不是 React合成事件 */</span>
    <span class="hljs-keyword">if</span>(registrationNameModules.<span class="hljs-title function_">hasOwnProperty</span>(propKey)){
         <span class="hljs-comment">/* 这里多个函数简化了，如果是合成事件， 传入成事件名称 onClick ，向document注册事件  */</span>
         <span class="hljs-title function_">legacyListenToEvent</span>(registrationName, <span class="hljs-variable language_">document</span>）;
    }
}
</code></pre>
<p>diffProperties函数在diff props 如果发现时合成事件就会调用legacyListenToEvent函数，注册事件监听器。</p>
<ol start="2">
<li>legacyListenToEvent 注册事件监听器</li>
</ol>
<pre><code class="language-javascript"><span class="hljs-comment">//  registrationName -&gt; onClick 事件</span>
<span class="hljs-comment">//  mountAt -&gt; document or container</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">legacyListenToEvent</span>(<span class="hljs-params">registrationName，mountAt</span>){
   <span class="hljs-keyword">const</span> dependencies = registrationNameDependencies[registrationName]; <span class="hljs-comment">// 根据 onClick 获取  onClick 依赖的事件数组 [ &#x27;click&#x27; ]。</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; dependencies.<span class="hljs-property">length</span>; i++) {
        <span class="hljs-keyword">const</span> dependency = dependencies[i];
        <span class="hljs-comment">//这个经过多个函数简化，如果是 click 基础事件，会走 legacyTrapBubbledEvent ,而且都是按照冒泡处理</span>
        <span class="hljs-title function_">legacyTrapBubbledEvent</span>(dependency, mountAt);
  }
}
</code></pre>
<p>legacyTrapBubbledEvent 就是执行将绑定真正的dom事件的函数（冒泡处理）</p>
<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">legacyTrapBubbledEvent</span>(<span class="hljs-params">topLevelType,element</span>){
   <span class="hljs-title function_">addTrappedEventListener</span>(element,topLevelType,<span class="hljs-variable constant_">PLUGIN_EVENT_SYSTEM</span>,<span class="hljs-literal">false</span>)
}
</code></pre>
<p>第三步在legacyListenToEvent函数中，先找到react合成事件对应的原生事件集合，比如 onClick -&gt; ['click'] , onChange -&gt; [blur , change , input , keydown , keyup]，然后遍历依赖项的数组，绑定事件。</p>
<p>react 对于click等基础事件，会默认按事件冒泡阶段的事件处理。</p>
<ol start="3">
<li>绑定dispatchEvent进行事件监听。</li>
</ol>
<p>react是如何绑定事件到document。</p>
<pre><code class="language-javascript"><span class="hljs-comment">/*
  targetContainer -&gt; document
  topLevelType -&gt;  click
  capture = false
*/</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">addTrappedEventListener</span>(<span class="hljs-params">targetContainer,topLevelType,eventSystemFlags,capture</span>){
   <span class="hljs-keyword">const</span> listener = dispatchEvent.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>,topLevelType,eventSystemFlags,targetContainer) 
   <span class="hljs-keyword">if</span>(capture){
       <span class="hljs-comment">// 事件捕获阶段处理函数。</span>
   }<span class="hljs-keyword">else</span>{
       <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> 重要, 这里进行真正的事件绑定。*/</span>
      targetContainer.<span class="hljs-title function_">addEventListener</span>(topLevelType,listener,<span class="hljs-literal">false</span>) <span class="hljs-comment">// document.addEventListener(&#x27;click&#x27;,listener,false)</span>
   }
}

</code></pre>
<p>第四步，绑定事件统一处理函数 dispatchEvent ，绑定几个默认参数，事件类型topLevelType 还有绑定容器 document，然后真正的事件绑定，添加事件监听器addEventListener。</p>
<h3>事件绑定过程总结</h3>
<ul>
<li>在react diff dom元素类型的fiber的props的时候，发现是react合成事件，就会按事件系统逻辑单独处理。</li>
<li>根据react 合成事件类型，找到对应的原生事件类型，然后调用判断原生事件类型，大部分事件都按照冒泡逻辑处理，少数事件会按照捕获逻辑处理。</li>
<li>调用addTrappedEventListener 进行真正的事件绑定，绑定document上，dispatchEvent为统一的事件处理函数。</li>
</ul>
<h2>事件触发</h2>
<h3>事件触发处理函数 dispatchEvent</h3>
<p>react事件注册时候，统一的监听器dispathchEvent，也就是当按钮被点击之后，首先执行的是dispatchEvent函数，dispatchEvent前三个参数已经被bind了，所以真正的事件源对象event，被默认绑定成第四个参数。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchEvent</span>(<span class="hljs-params">topLevelType,eventSystemFlags,targetContainer,nativeEvent</span>){
    <span class="hljs-comment">/* 尝试调度事件 */</span>
    <span class="hljs-keyword">const</span> blockedOn = <span class="hljs-title function_">attemptToDispatchEvent</span>( topLevelType,eventSystemFlags, targetContainer, nativeEvent);
}
</code></pre>
<pre><code class="language-javascript"><span class="hljs-comment">/*
topLevelType -&gt; click
eventSystemFlags -&gt; 1
targetContainer -&gt; document
nativeEvent -&gt; 原生事件的 event 对象
*/</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">attemptToDispatchEvent</span>(<span class="hljs-params">topLevelType,eventSystemFlags,targetContainer,nativeEvent</span>){
    <span class="hljs-comment">/* 获取原生事件 e.target */</span>
    <span class="hljs-keyword">const</span> nativeEventTarget = <span class="hljs-title function_">getEventTarget</span>(nativeEvent)
    <span class="hljs-comment">/* 获取当前事件，最近的dom类型fiber ，我们 demo中 button 按钮对应的 fiber */</span>
    <span class="hljs-keyword">let</span> targetInst = <span class="hljs-title function_">getClosestInstanceFromNode</span>(nativeEventTarget); 
    <span class="hljs-comment">/* 重要：进入legacy模式的事件处理系统 */</span>
    <span class="hljs-title function_">dispatchEventForLegacyPluginEventSystem</span>(topLevelType,eventSystemFlags,nativeEvent,targetInst,);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}
</code></pre>
<ul>
<li>首先根据真实的事件源对象,找到e.target 真实的dom元素</li>
<li>根据dom元素，找到它对应的fiber对象targetInst.</li>
<li>然后正式进去legacy模式的事件处理系统。</li>
</ul>
<p>react怎么通过原生dom元素，找到对应的fiber的呢？
getClosestInstanceFromNode 可以找到当前传入的dom对应的最近的元素类型的fiber对象。react在初始化真实的dom的时候，用一个随记的key 。
internalInstanceKey指针纸箱了当前dom对应的fiber对象，fiber对象用stateNode指向了当前的dom元素。</p>
<pre><code>// 声明随机key
var internalInstanceKey = '__reactInternalInstance
            </section>
        </div>
    </div>
</body>
<style>
    body,
    div,
    dl,
    dt,
    dd,
    ul,
    ol,
    li,
    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    pre,
    code,
    legend,
    button form,
    fieldset,
    input,
    textarea,
    p,
    blockquote,
    th,
    td {
        padding: 0;
        margin: 0;
    }

    body {
        color: #34495e;
    }

    a {
        text-decoration: none;
        color: #505d6b;

    }

    a:hover {
        text-decoration: underline;
    }

    .language-javascript .hljs-keyword {
        color: coral
    }

    .language-javascript .hljs-title {
        color: darkcyan;
    }

    .page {
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        display: flex;
        align-items: flex-start;
        justify-content: flex-start;
    }

    .sider {
        flex-shrink: 0;
        box-sizing: border-box;
        padding: 10px;
        height: 100%;
        min-width: 200px;
        width: 300px;
        background-color: white;
        overflow: hidden;
        overflow-y: auto;
        border: 1px solid rgba(0, 0, 0, 0.07);
    }

    .content {
        height: 100%;
        flex-grow: 1;
        padding: 0 30px;
        background-color: white;
        overflow: hidden;
        overflow-y: auto;
    }

    .level-1,
    .level-2,
    .level-3 {
        color: #505d6b;
        font-size: 14px;
        font-weight: 400;
        overflow: hidden;
        text-decoration: none;
        text-overflow: ellipsis;
        white-space: nowrap;
        margin-top: 6px;
        line-height: 30px;
    }

    .level-1 {
        text-indent: 10px;
    }

    .level-2 {
        text-indent: 20px;
    }

    .level-3 {
        text-indent: 30px;
    }

    .folder {
        font-weight: 600;
        margin-top: 6px;
    }

    section {
        min-width: 880px;
        max-width: 1200px;
        margin: 0 auto;
        padding: 30px 0;
    }

    img {
        max-width: 100%;
    }

    section p {
        margin: 1.2em 0;
        line-height: 25px;
    }

    section h1,
    section h2,
    section h3,
    section h4,
    section h5 {
        color: #2c3e50;
        font-weight: 600;
    }

    hr {
        border: none;
        border-bottom: 1px solid #eee;
        margin: 2em 0;
    }

    h1 {
        margin-top: 40px;
    }

    h2 {
        margin-top: 32px;
    }

    h3 {
        margin-top: 24px;
    }

    h4 {
        margin-top: 16px;
    }

    h5 {
        margin-top: 8px;
    }

    section ul,
    section ol {
        padding-left: 24px;
    }

    section pre {
        padding: 20px 44px;
        line-height: 24px;
        overflow: auto;
        word-wrap: normal;
        background-color: #f8f8f8;
        border-radius: 5px;
        margin: 30px 0;
    }

    section table {
        border-collapse: collapse;
        border-spacing: 0;
        display: block;
        margin-bottom: 1rem;
        overflow: auto;
        width: 100%;
    }

    section tr {
        border-top: 1px solid #ccc;
    }

    section td {
        border: 1px solid #ddd;
        padding: 6px 13px;
    }

    section th {
        border: 1px solid #ddd;
        padding: 6px 13px;
    }

    thead {
        display: table-header-group;
        vertical-align: middle;
        border-color: inherit;
    }

    code {
        margin: 30px 2px;
    }
</style>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        let url = location.href;
        let aEl = document.getElementsByTagName('a');
        for (let el of aEl) {
            if (el.href === url) {
                el.style.color = 'rgb(66, 185, 131)'
            }
        }
    })
</script>

</html> + randomKey;

// 使用随机key 
function getClosestInstanceFromNode(targetNode){
  // targetNode -dom  targetInst -&gt; 与之对应的fiber对象
  var targetInst = targetNode[internalInstanceKey];
}
</code></pre>
<h3>legacy 事件处理系统与批量更新</h3>
<pre><code class="language-javascript"><span class="hljs-comment">/* topLevelType - click事件 ｜ eventSystemFlags = 1 ｜ nativeEvent = 事件源对象  ｜ targetInst = 元素对应的fiber对象  */</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatchEventForLegacyPluginEventSystem</span>(<span class="hljs-params">topLevelType,eventSystemFlags,nativeEvent,targetInst</span>){
    <span class="hljs-comment">/* 从React 事件池中取出一个，将 topLevelType ，targetInst 等属性赋予给事件  */</span>
    <span class="hljs-keyword">const</span> bookKeeping = <span class="hljs-title function_">getTopLevelCallbackBookKeeping</span>(topLevelType,nativeEvent,targetInst,eventSystemFlags);
    <span class="hljs-keyword">try</span> { <span class="hljs-comment">/* 执行批量更新 handleTopLevel 为事件处理的主要函数 */</span>
    <span class="hljs-title function_">batchedEventUpdates</span>(handleTopLevel, bookKeeping);
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">/* 释放事件池 */</span>  
    <span class="hljs-title function_">releaseTopLevelCallbackBookKeeping</span>(bookKeeping);
  }
}
</code></pre>
<p>batchedEventUpdates 是批量更新的主要函数。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">batchedEventUpdates</span>(<span class="hljs-params">fn,a</span>){
    isBatchingEventUpdates = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">try</span>{
       <span class="hljs-title function_">fn</span>(a) <span class="hljs-comment">// handleTopLevel(bookKeeping)</span>
    }<span class="hljs-keyword">finally</span>{
        isBatchingEventUpdates = <span class="hljs-literal">false</span>
    }
}
</code></pre>
<p>react 通过isBatchingEventUpdates来控制是否启动批量更新。fn(a)时间上调用的是handleTopLevel(bookKeeping)，js是单线程，因为js是单线程的，所以在组件中写的事件处理函数时机是在handleTopLevel(bookKeeping)中执行的。如果在用户事件处理函数中触发了setState，那么就能读取到 isBatchingEventUpdates = true 。</p>
<pre><code>state={number:0}
handerClick = () =&gt;{
    this.setState({number: this.state.number + 1   })
    console.log(this.state.number) //0
    this.setState({number: this.state.number + 1   })
    console.log(this.state.number) //0
    setTimeout(()=&gt;{
        this.setState({number: this.state.number + 1   })
        console.log(this.state.number) //2
        this.setState({number: this.state.number + 1   })
        console.log(this.state.number)// 3
    })
}
</code></pre>
<p>第一二个setState在批量更新条件之内执行，所以不会打印最新的值。
如果发生在setTimeout中，eventloop放在下一次事件循环中执行，此刻batchedEventUpdates 中已经执行完了isBatchingEventUpdates = false , 批量更新被打破，就可以访问到最新的变化的值。</p>
<h3>执行事件插件函数</h3>
<pre><code>// 流程简化后
// topLevelType - click  
// targetInst - button Fiber
// nativeEvent
function handleTopLevel(bookKeeping){
    const { topLevelType,targetInst,nativeEvent,eventTarget, eventSystemFlags} = bookKeeping
    for(let i=0; i &lt; plugins.length;i++ ){
        const possiblePlugin = plugins[i];
        /* 找到对应的事件插件，形成对应的合成event，形成事件执行队列  */
        const  extractedEvents = possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,eventTarget,eventSystemFlags)  
    }
    if (extractedEvents) {
        events = accumulateInto(events, extractedEvents);
    }
    /* 执行事件处理函数 */
    runEventsInBatch(events);
}
</code></pre>
<p>handleTopLevel最后的处理逻辑是执行事件处理插件中的处理函数 extractEvents, react是采用事件合成，事件统一绑定，并且在组件中的时间处理函数，也不是真正的执行函数dispatchAction,那么我们在点击事件对象event，也是react单独合成处理的，里面封装了stopPropagetion和preventDefault。这样的好处是不需要跨浏览器处理兼容问题，统一交给react底层处理。</p>
<h3>extractEvents 形成事件对象和是按处理函数队列</h3>
<p>extraEvent 是整个事件系统核心代码。</p>
<pre><code class="language-javascript"><span class="hljs-keyword">const</span>  <span class="hljs-title class_">SimpleEventPlugin</span> = {
    <span class="hljs-attr">extractEvents</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params">topLevelType,targetInst,nativeEvent,nativeEventTarget</span>){
        <span class="hljs-keyword">const</span> dispatchConfig = topLevelEventsToDispatchConfig.<span class="hljs-title function_">get</span>(topLevelType);
        <span class="hljs-keyword">if</span> (!dispatchConfig) {
            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
        }
        <span class="hljs-keyword">switch</span>(topLevelType){
            <span class="hljs-attr">default</span>:
            <span class="hljs-title class_">EventConstructor</span> = <span class="hljs-title class_">SyntheticEvent</span>;
            <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-comment">/* 产生事件源对象 */</span>
        <span class="hljs-keyword">const</span> event = <span class="hljs-title class_">EventConstructor</span>.<span class="hljs-title function_">getPooled</span>(dispatchConfig,targetInst,nativeEvent,nativeEventTarget)
        <span class="hljs-keyword">const</span> phasedRegistrationNames = event.<span class="hljs-property">dispatchConfig</span>.<span class="hljs-property">phasedRegistrationNames</span>;
        <span class="hljs-keyword">const</span> dispatchListeners = [];
        <span class="hljs-keyword">const</span> {bubbled, captured} = phasedRegistrationNames; <span class="hljs-comment">/* onClick / onClickCapture */</span>
        <span class="hljs-keyword">const</span> dispatchInstances = [];
        <span class="hljs-comment">/* 从事件源开始逐渐向上，查找dom元素类型HostComponent对应的fiber ，收集上面的React合成事件，onClick / onClickCapture  */</span>
         <span class="hljs-keyword">while</span> (instance !== <span class="hljs-literal">null</span>) {
              <span class="hljs-keyword">const</span> {stateNode, tag} = instance;
              <span class="hljs-keyword">if</span> (tag === <span class="hljs-title class_">HostComponent</span> &amp;&amp; stateNode !== <span class="hljs-literal">null</span>) { <span class="hljs-comment">/* DOM 元素 */</span>
                   <span class="hljs-keyword">const</span> currentTarget = stateNode;
                   <span class="hljs-keyword">if</span> (captured !== <span class="hljs-literal">null</span>) { <span class="hljs-comment">/* 事件捕获 */</span>
                        <span class="hljs-comment">/* 在事件捕获阶段,真正的事件处理函数 */</span>
                        <span class="hljs-keyword">const</span> captureListener = <span class="hljs-title function_">getListener</span>(instance, captured);
                        <span class="hljs-keyword">if</span> (captureListener != <span class="hljs-literal">null</span>) {
                        <span class="hljs-comment">/* 对应发生在事件捕获阶段的处理函数，逻辑是将执行函数unshift添加到队列的最前面 */</span>
                            dispatchListeners.<span class="hljs-title function_">unshift</span>(captureListener);
                            dispatchInstances.<span class="hljs-title function_">unshift</span>(instance);
                            dispatchCurrentTargets.<span class="hljs-title function_">unshift</span>(currentTarget);
                        }
                    }
                    <span class="hljs-keyword">if</span> (bubbled !== <span class="hljs-literal">null</span>) { <span class="hljs-comment">/* 事件冒泡 */</span>
                        <span class="hljs-comment">/* 事件冒泡阶段，真正的事件处理函数，逻辑是将执行函数push到执行队列的最后面 */</span>
                        <span class="hljs-keyword">const</span> bubbleListener = <span class="hljs-title function_">getListener</span>(instance, bubbled);
                        <span class="hljs-keyword">if</span> (bubbleListener != <span class="hljs-literal">null</span>) {
                            dispatchListeners.<span class="hljs-title function_">push</span>(bubbleListener);
                            dispatchInstances.<span class="hljs-title function_">push</span>(instance);
                            dispatchCurrentTargets.<span class="hljs-title function_">push</span>(currentTarget);
                        }
                    }
              }
              instance = instance.<span class="hljs-property">return</span>;
         }
          <span class="hljs-keyword">if</span> (dispatchListeners.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) {
              <span class="hljs-comment">/* 将函数执行队列，挂到事件对象event上 */</span>
            event.<span class="hljs-property">_dispatchListeners</span> = dispatchListeners;
            event.<span class="hljs-property">_dispatchInstances</span> = dispatchInstances;
            event.<span class="hljs-property">_dispatchCurrentTargets</span> = dispatchCurrentTargets;
         }
        <span class="hljs-keyword">return</span> event
    }
}

</code></pre>
<ul>
<li>首先形成react事件独有的合成事件源对象，这个对象保存整个事件的信息，将作为参数传递给真正的事件处理函数 。</li>
<li>然后去声明事件执行队列，按照冒泡 和 捕获 逻辑。从事件源开始逐渐向上，查找dom元素类型HostComponent对应的fiber，收集上面的react合成事件。</li>
<li>最后将事件执行队列，保存到react事件源对象上，等待执行。</li>
</ul>
<h3>事件触发总结</h3>
<ul>
<li>通过统一的事件处理函数 dispatchEvent 进行批量更新batchUpdate</li>
<li>然后执行事件对应的处理插件中的extractEvents，合成事件源对象，每次react会从事件源开始，从上遍历类型为hostComponent【dom类型的fiber对象】，判断props中是否有当前响应的事件，最后形成一个事件执行队列。</li>
<li>最后通过runEventsInBatch执行队列，如果发现阻止冒泡，就会跳出循环，最后重置事件源，完成流程。</li>
</ul>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68a8f1b7f35c4ecbb58cf9d676cd29ad~tplv-k3u1fbpfcp-watermark.awebp" alt=""></p>
<h3>react 17 改版</h3>
<p>事件统一绑定到了挂载的根节点上，目标是为了适应微前端框架。</p>
<h2>总结</h2>
<p>本文从事件合成，事件绑定，事件触发三个方面详细介绍了React事件系统原理。
贴一下原文地址</p>
<blockquote>
<p>https://juejin.cn/post/6955636911214067720#heading-23</p>
</blockquote>

            </section>
        </div>
    </div>
</body>
<style>
    body,
    div,
    dl,
    dt,
    dd,
    ul,
    ol,
    li,
    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    pre,
    code,
    legend,
    button form,
    fieldset,
    input,
    textarea,
    p,
    blockquote,
    th,
    td {
        padding: 0;
        margin: 0;
    }

    body {
        color: #34495e;
    }

    a {
        text-decoration: none;
        color: #505d6b;

    }

    a:hover {
        text-decoration: underline;
    }

    .language-javascript .hljs-keyword {
        color: coral
    }

    .language-javascript .hljs-title {
        color: darkcyan;
    }

    .page {
        height: 100vh;
        width: 100vw;
        overflow: hidden;
        display: flex;
        align-items: flex-start;
        justify-content: flex-start;
    }

    .sider {
        flex-shrink: 0;
        box-sizing: border-box;
        padding: 10px;
        height: 100%;
        min-width: 200px;
        width: 300px;
        background-color: white;
        overflow: hidden;
        overflow-y: auto;
        border: 1px solid rgba(0, 0, 0, 0.07);
    }

    .content {
        height: 100%;
        flex-grow: 1;
        padding: 0 30px;
        background-color: white;
        overflow: hidden;
        overflow-y: auto;
    }

    .level-1,
    .level-2,
    .level-3 {
        color: #505d6b;
        font-size: 14px;
        font-weight: 400;
        overflow: hidden;
        text-decoration: none;
        text-overflow: ellipsis;
        white-space: nowrap;
        margin-top: 6px;
        line-height: 30px;
    }

    .level-1 {
        text-indent: 10px;
    }

    .level-2 {
        text-indent: 20px;
    }

    .level-3 {
        text-indent: 30px;
    }

    .folder {
        font-weight: 600;
        margin-top: 6px;
    }

    section {
        min-width: 880px;
        max-width: 1200px;
        margin: 0 auto;
        padding: 30px 0;
    }

    img {
        max-width: 100%;
    }

    section p {
        margin: 1.2em 0;
        line-height: 25px;
    }

    section h1,
    section h2,
    section h3,
    section h4,
    section h5 {
        color: #2c3e50;
        font-weight: 600;
    }

    hr {
        border: none;
        border-bottom: 1px solid #eee;
        margin: 2em 0;
    }

    h1 {
        margin-top: 40px;
    }

    h2 {
        margin-top: 32px;
    }

    h3 {
        margin-top: 24px;
    }

    h4 {
        margin-top: 16px;
    }

    h5 {
        margin-top: 8px;
    }

    section ul,
    section ol {
        padding-left: 24px;
    }

    section pre {
        padding: 20px 44px;
        line-height: 24px;
        overflow: auto;
        word-wrap: normal;
        background-color: #f8f8f8;
        border-radius: 5px;
        margin: 30px 0;
    }

    section table {
        border-collapse: collapse;
        border-spacing: 0;
        display: block;
        margin-bottom: 1rem;
        overflow: auto;
        width: 100%;
    }

    section tr {
        border-top: 1px solid #ccc;
    }

    section td {
        border: 1px solid #ddd;
        padding: 6px 13px;
    }

    section th {
        border: 1px solid #ddd;
        padding: 6px 13px;
    }

    thead {
        display: table-header-group;
        vertical-align: middle;
        border-color: inherit;
    }

    code {
        margin: 30px 2px;
    }
</style>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        let url = location.href;
        let aEl = document.getElementsByTagName('a');
        for (let el of aEl) {
            if (el.href === url) {
                el.style.color = 'rgb(66, 185, 131)'
            }
        }
    })
</script>

</html>