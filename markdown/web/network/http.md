<center>

# HTTP


</center>

http大家应该都不陌生，无论是打开网页，还是发送请求，都会使用到。

## 发展历程

http最为互联网的基石，经历了多代的更新。

### HTTP/0.9
http协议的齐元，一开始并没有版本号，后来为了和其他版本相区分，所以定义为HTTP/0.9

此版本作为起源，是一个单行协议，没有请求头，只有一个GET方法，因为最初的目标是传输只有文本的HTML文件【当年的美国老网站都是没有样式的】


### HTTP/1.0
随后几年，HTTP逐渐流行起来。1996年制定了HTTP/1.0协议。

1.0版本更新了许多内容
* 增加了POST和HEAD
  * POST用于上传数据
  * HEAD用于获取存在信息
* 引入了http头的概念，无论是对于请求还是响应，允许传送元数据，更具拓展性。
* 内容协商。在HTTP头Content-Type的帮助下，允许传输HTML文件意外的其他类型文件。
* 新增了HTTP头，就意味着还增加了状态码，字符集支持，内容编码等。

### HTTP/1.1
1.0版本新增的功能大大增加了http的拓展性。
1.1版本新增了一些特性
* 长连接
* 管线化技术：复用请求，降低延迟
* 额外的缓存控制机制。1.1版本引入了ETag 和 IF-Unmodified-Since，If-Match，If-None-Match等。
* 额外的内容协商机制
* Host字段
* 分块传输编码: 通过Content-Length，Accept-Ranges，Content-Range等头字段，允许服务器发送给客户端数据可以分成多少部分。

局限性
* 虽然加入了长连接，但是在域名分片等情况下人需要创建多个连接，小号资源，给服务器带来性能压力。
* 队头阻塞： 浏览器可以一次性发送对个请求，但是由于没有响应标识来区分那个是响应是哪个请求的，因此还是需要返回是按顺序返回的，所以若是前一个请求需要耗时很久，那么后面的请求基石服务器已经处理完了，人需要等前面的请求处理完成之后才能按顺序返回。
* 协议开销大。请求头基本不变，但是人需要一遍一遍的传送。

### HTTP/2.0
http2.0版本基于Google工程师剔除的SPDY协议。
新增的特性
* 二进制传输 + 二进制分帧： 通过在应用层和传输层质检增加一个二进制分层帧，将所有传输信息分割成更小的消息帧，并且对他们进行封装，加上流标识符等。
* 多路复用。多个请求可以复用同一个TCP连接，传输以流的方式进行，不同请求的帧交错的经发送队列发送出去，不用在意发送顺序，因为接收端会根据流标识组创城一个完整的包
* 流量控制，基于TCP的流量控制，使用多种流量控制算法。
* 请求优先级
* 头部压缩
* 服务端推送

局限：
基于二进制和多路复用，解决了队头阻塞问题。
* 传输层TCP队头阻塞： TCP一单丢包，就会触发重传，阻塞后续帧的传输。
* 多路复用会增加服务器压力。


### HTTPS
除了在传输控制上，http还有一个缺陷，就是明文传输，所以，诞生了HTTPS。

HTTPS = HTTP + SSL/TLS

HTTPS默认工作在TCP协议443端口上，工作流程如下：
* TCP三次握手建立连接
* 客户端认证服务器数字证书
* 客户端产生密钥，用服务端公钥加密。
* 传送给服务端，服务端私钥解密。
* 使用客户端获取的key来进行通信

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a3754cb0707476695b20575e165022e~tplv-k3u1fbpfcp-watermark.awebp)


### HTTP/3.0
http2.0几大的提升了传输性能，TCP成为了下一个性能瓶颈。

TCP队头阻塞的产生是因为tcp自身的实现机制决定的，如果想要避免tcp队头阻塞，只能舍弃TCP协议了。

于是乎 基于UDP协议推出了QUIC 【快速UDP互联网连接】的实现行网络协议，最终演变成HTTP/3.0

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a50cc8b7bfe9436c842bb47e8935e63f~tplv-k3u1fbpfcp-watermark.awebp)
传输层UPD保证传输效率，应用层QUIC提供可靠，安全传输等。

## HTTP 报文
http报文是http协议交流信息的载体。
### HTTP请求报文
```
GET / HTTP/1.1
Host: groove-zhang.cn
Connection: keep-alive
Pragma: no-cache
Cache-Control: no-cache
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Cookie: Hm_lvt_df8864fcb892656c1f03a2cc76a1ce10=1639634057,1640691942,1641292084; _ga=GA1.2.868356561.1641901919; Hm_lpvt_df8864fcb892656c1f03a2cc76a1ce10=1641958114
```
上面就是个一个http报文。其内包括
* 请求方法
* url
* HTTP版本
* 报文头
* 报文体

#### 常见的HTTP报文头属性
* Acpect:  告诉服务端，客户端接受什么类型的数据返回。
* Referer: 表示这个请求是从哪个URL进来的。用来追溯来源。
* Cache-Control： 对缓存进行控制，一个请求希望响应的内容在客户端缓存，或者不希望缓存也可以通过这个报文头来设置。
* Host：指定要请求的资源所在的主机和端口。
* User-Agent作用，告诉服务器客户端使用的操作系统，浏览器版本和名称。


### HTTP响应报文
响应报文中包括：
* 响应报文协议及版本
* 状态码及状态描述
* 响应头
* 响应体

#### http状态码
![](https://upload-images.jianshu.io/upload_images/12603307-9e9f12a5f5055b34.png?imageMogr2/auto-orient/strip|imageView2/2/w/587/format/webp)

* 1xx 消息
  * 100 服务器接受请求头，并且客户端应据需发送请求体。
  * 101 服务器已经理解了客户端的请求，病通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。【使用socket使用】
  * 102 WebDAV 请求可能包含许多设计文件操作的子请求，需要很长时间菜能完成请求。表示服务器已经收到并正在处理请求，但是没有响应可用。
  * 103 用来在最终的HTTP消息之前返回一些响应头。

* 2XX 成功
  * 200 请求已成功，请求所希望的响应头和数据题将随此响应返回。
  * 201 请求已经被实现，而且一个心得资源已经根据请求的需求二创建。
  * 202 服务器已经接受请求，但尚未处理。
  * 203 服务器是一个转换代理服务器，以 200 状态码为起源，但是回应了原始响应的修改版本。
  * 204 服务器成功处理了请求，没有返回任何内容。
  * 205 服务器成功处理了请求，但是没有返回任何内容，此请求要求请求者重置文档视图。
  * 206 服务器成功处理了部分GET请求，多段下载。
  * 207 代表之后的消息体是个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。
  * 208 DAV绑定的成员在响应之前的部分被列举，且未被再次包含。
  * 226 服务器已经满足了对资源的请求，对实体请求的一个或多个实体操作的结果表示。

* 3XX 重定向 这类状态码表示客户端需要进一步的操作才能完成请求。
  * 300 被请求的资源有一系列的可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。
  * 301 被请求的资源永久挪到新位置了。
  * 302 要求客户端临时重定向。
  * 303 对应当前请求的响应可以在另一个URI上被找到。
  * 304 协商缓存
  * 305 被请求的资源必须通过指定代理才能访问。
  * 306 废弃
  * 307 请求应该与另一个URI重复，但后续的请求应仍使用原石的URI。
  * 308 请求和所有将来的请求应该使用另一个URI。

* 4XX 客户端错误
  * 400 明显的客户端错误，服务器不能或者不会处理该请求。
  * 401 未验证。
  * 402 准备用作支付，但是目前还没有厂商在使用。
  * 403 服务器已经理解请求，但是拒绝执行。
  * 404 无资源
  * 405 请求方法不被允许
  * 406 内容协商，请求资源的内容特征无法满足请求头的条件。
  * 407 客户端需要在代理服务器上进行身份验证。
  * 408 请求超时
  * 4XX后面还有还多种，就不一一列举了

* 5XX 服务器错误
  * 500 通常错误消息
  * 501 服务器不支持当前请求所需的某个功能
  * 502 王国错误
  * 503 服务器维护
  * 504 上游服务器或者辅助服务器未响应
  * 505 服务器拒绝或者不支持请求的HTTP版本
  * 506 服务器存在内部配置错误
  * 507 服务器无法储存完成请求所需要的内容
  * 508 服务器死循环

## HTTP的TCP连接
### TCP
传输控制协议（Transmission Control Protocol) 是一种面向连接的，可靠的，基于字节流的传输层通信协议。

从上述的概念中可以得知tcp的几个特点：
* 面向连接
* 可靠
* 基于字节流

那么我们从上面三个方面来了解TCP协议

#### 面向连接
tcp提供的是一种面向连接的传输层协议，既然要连接的话，首先需要建立连接。

##### 建立连接
tcp建立连接需要进行三次握手。

握手过程如下：
* 客户端发送SYN(SQE=X)报文发送给服务端。进入SYN_SEND的状态
* 服务端收到SYN报文，回应一个SYN(SEQ=Y),ACK(ACK = X+1)报文，进入SYN_RECV状态。
* 客户端收到服务端的SYN报文，回应一个ACK(ACK = Y+1)报文，进入established状态。

三次握手之后，可以传输数据了。

那能不能两次握手啊？

如果两次握手，服务端在收到客户端的请求后直接开始发送数据的话，就肯能存在 服务端发送数据并没有触达到客户端。

##### 断开连接
因为TCP的半关闭机制，所以需要四次通信才能关闭连接。

* 某个应用进程发送主动关闭请求，改短的tcp发送一个FIN分节，表示数据发送完毕
* 接受这个FIN的端执行被动关闭，这个FIN由TCP确认。对端会返回一个ACK。
* 接受FIN的端会调用close 关闭它的套接字，这也会导致发送一个FIN消息给对端。
* 然后最后对端返回一个ACK。

##### 为什么客户端需要2MSL后才关闭tcp连接
1、为了保证客户端发送的最后一个ACK报文段能够到达服务器。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

2、他还可以防止已失效的报文段。客户端在发送最后一个ACK之后，再经过经过2MSL，就可以使本链接持续时间内所产生的所有报文段都从网络中消失。从保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。

#### 可靠
TCP是可靠传输是靠什么来实现的呢？

首先，先要明白tcp的传输方式，他是面向连接的，就意味着是1对1的连接，而不是广播或者多播这样的形式。

基于1对1的形式,用以下功能来保证保证可靠性:
* 应用数据被分割成TCP认为最适合发送的数据块。
* TCP发送一个段后，会启动一个定时器，等待目的端收到这个报文段。如果没有及时收到确认，则会重发该报文段。
* tcp将会保持它首部和数据的校验和。
* tcp数据段作为IP数据包来传输，IP数据可能会失序，所必要时 TCP将对收到的数据进行重新排序。
* IP数据报会重复，所以TCP的接收端必须丢弃重复的数据。
* TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间，tcp的接收端只允许另一端发送接收端缓冲区所能接纳的数据。

#### 流
在http使用中，我们发送请求，得到结果，很容易把tcp理解为一个应答式的协议,但是事实并不是如此，当我们调用api完成数据'发送'以后，数据并没有立马传送出去，而是从应用程序拷贝到操作系统内核协议栈中，至于什么时候真正被发送出去，取决与发送窗口，拥塞窗口以及当前发送缓冲区的大小等条件。

## 总结 
写了上面那么多，总结起来就是 很累了，自己看吧