## webpack

### webpack 解析过程
当你构建一个webpack的配置文件，执行webpack的时候，首先会执行node_modules中的bin文件中的webpack.js 

webpack的运行流程是一个串行的过程，葱启动到结束会依次执行以下流程： 

* 初始化参数： 从配置文件和shell中获取参数
* 开始编译：用上面的参数初始化compiler对象，加载所有配置的插件，执行run方法进行编译。
* 确定入口： 根据配置，找到入口文件。
* 编译模块：从入口文件触发，调用相关的loader去处理文件
* 完成模块编译：在经过loader翻译完后，每个模块被翻译后的最终内容和依赖关系
* 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含对个模块的chunk，在将每个chunk转换成一个单独的文件加入到输出列表。
* 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入文件系统；

在以上过程中，webpack会在特定的时间播放出特定的事件，插件在监听到感兴趣的事件的时候，会执行特定的逻辑，并且插件可以调用webpack提供的api改变webpack的运行结果。

### loader和plugin的区别
loader是一个方法，是对收到的内容进行一个转换，返回转换结果。

plugin是插件，为webpack增加功能的。

### 文件监听原理
webpack开启监听模式，有两种方式

*  shell --watch参数
*  配置文件中watch：true

原理：轮询判断文件的最后修改时间是否变化，如果变化，并不会立刻告诉监听者，而是先缓存起来，等到aggregateTimeout后再执行

### 热更新原理
HMR： 维护一个websocket，当本地资源发生变化时。本地服务会想浏览器推送更新，带上构建的hash，让客户端进行一次比较，客户端对比出差以后会ajax获取更新内容，这样客户端可以借助这些信息继续向本地服务器发起jsonp请求获取chunk的增量更新。


### 优化webpack构建速度

1. 使用高版本的webpack和node
2. 多进程、多实例构建
3. 压缩代码
4. 图片压缩
5. 缩小打包作用域
6. 提取页面公共资源
7. Dll分包
8. 利用缓存 
9. tree-shaking
10. scope hoisting